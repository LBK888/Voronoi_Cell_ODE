{
  "grid_shape_x": 18,
  "grid_shape_y": 12,
  "cell_dist": "1.0",
  "pos_rand": "0.35",
  "move_random": true,
  "move_random_strength": "0.05",
  "move_away": false,
  "move_away_strength": "0.01",
  "move_ce": true,
  "move_ce_strength": "0.02",
  "move_repulsion": true,
  "move_repulsion_strength": "0.08",
  "move_division": false,
  "move_division_n": 2,
  "move_division_method": 0,
  "move_apoptosis": false,
  "move_apoptosis_n": 2,
  "move_apoptosis_method": 0,
  "ode": "def ode(Y, t, params, cell_positions):\n    p = params\n    dY = np.zeros_like(Y)\n    D, R, sD3, sD4 = Y[:,0], Y[:,1], Y[:,2], Y[:,3]\n    neighbors = get_voronoi_neighbors_wo_outer(cell_positions)\n    sigma_diff_sD3 = p.get('sigma_diff_sD3', 2.0)\n    sigma_diff_sD4 = p.get('sigma_diff_sD4', 2.0)\n    for i in range(Y.shape[0]):\n        neibs = neighbors[i]\n        if neibs:\n            weights = np.array(list(neibs.values()))\n            dvals = np.array([D[j] for j in neibs.keys()])\n            sD3_weighted = diffusion_weighted_mean(sD3, cell_positions, i, sigma_diff_sD3)\n            sD4_weighted = diffusion_weighted_mean(sD4, cell_positions, i, sigma_diff_sD4)\n            avgD = (\n                np.sum(dvals * weights) / np.sum(weights)\n                - p['Ktv3_inhib'] * sD3_weighted\n                - p['Ktv4_inhib'] * sD4_weighted\n            )\n        else:\n            dY[i,:] = 0\n            continue\n        dD = p['nu']*(1-p['sDtv3_ratio']-p['sDtv4_ratio'])*( p['betaD']/(1 + R[i]**p['h'])) - (1 + p['Dgr_Noise']*(np.random.randn()-0.5))*D[i]\n        dR = (p['betaR']*(avgD**p['m']))/(1 + avgD**p['m']) - R[i]\n        dsD3 = p['nu']*p['sDtv3_ratio']*(p['betaD']/(1 + R[i]**p['h'])) - p['Ktv3_Dgr']*sD3[i]\n        dsD4 = p['nu']*p['sDtv4_ratio']*(p['betaD']/(1 + R[i]**p['h'])) - p['Ktv4_Dgr']*sD4[i]\n        dY[i,0] = dD\n        dY[i,1] = dR \n        dY[i,2] = dsD3\n        dY[i,3] = dsD4\n    Y_new = Y + dY * p['dT'] if 'dT' in p else Y + dY\n    Y_new = np.clip(Y_new, 0, None)\n    dY = (Y_new - Y) / (p['dT'] if 'dT' in p else 1)\n    return dY",
  "params": "params = dict(\n    nu=1.0,\n    betaD=50.0,\n    betaR=50.0,\n    h=3,\n    m=3,\n    sDtv3_ratio=0.0765,\n    sDtv4_ratio=0.0734,\n    Ktv3_Dgr=0.4,\n    Ktv4_Dgr=0.5,\n    Ktv3_inhib=0.15,\n    Ktv4_inhib=0.3,\n    sigma_diff_sD3=2.5,\n    sigma_diff_sD4=4.0,\n    LI_off_Dgr=1.0,\n    Dgr_Noise=0.01,\n    sigma = None,\n    dT=1/20.0,\n    n_var=4,  \n    labels= ['DeltaC', 'Ractor', 'sD_tv3', 'sD_tv4']\n)",
  "color_func": "def color_func(Y, mode='polygon'):\n    if mode == 'polygon':\n        norm = (Y[:,0] - Y[:,0].min()) / (np.ptp(Y[:,0]) + 1e-8)\n        return plt.cm.Reds(norm)\n    elif mode == 'center':\n        norm = (Y[:,1] - Y[:,1].min()) / (np.ptp(Y[:,1]) + 1e-8)\n        return plt.cm.Blues(norm)\n    elif mode == 'membrane':\n        color = np.zeros((Y.shape[0], 4))  # RGBA\n        mask = Y[:,0] > 40\n        color[mask] = [1, 1, 0, 1]   # 黃色 (R,G,B,A)\n        color[~mask] = [0, 0, 0, 1]  # 黑色\n        return color\n    else:\n        return None",
  "T": "30",
  "replicate": "5",
  "repeats": "5",
  "grid_mode": 0
}